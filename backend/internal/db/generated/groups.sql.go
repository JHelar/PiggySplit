// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: groups.sql

package generated

import (
	"context"
	"time"
)

const archiveGroupById = `-- name: ArchiveGroupById :exec
UPDATE groups
SET state = "group_state:archived", updated_at = CURRENT_TIMESTAMP
    WHERE id IN (
        SELECT groups.id
        FROM groups
        INNER JOIN group_members
            ON groups.id=group_members.group_id
        WHERE groups.id=?1 AND group_members.role=?2 AND group_members.user_id=?3
    )
`

type ArchiveGroupByIdParams struct {
	GroupID    int64  `json:"group_id"`
	MemberRole string `json:"member_role"`
	UserID     int64  `json:"user_id"`
}

func (q *Queries) ArchiveGroupById(ctx context.Context, arg ArchiveGroupByIdParams) error {
	_, err := q.db.ExecContext(ctx, archiveGroupById, arg.GroupID, arg.MemberRole, arg.UserID)
	return err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO groups (display_name, state, color_theme, currency_code) VALUES (?, ?, ?, ?)
    RETURNING id, display_name, state, color_theme, currency_code, created_at, updated_at
`

type CreateGroupParams struct {
	DisplayName  string `json:"display_name"`
	State        string `json:"state"`
	ColorTheme   string `json:"color_theme"`
	CurrencyCode string `json:"currency_code"`
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, createGroup,
		arg.DisplayName,
		arg.State,
		arg.ColorTheme,
		arg.CurrencyCode,
	)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.State,
		&i.ColorTheme,
		&i.CurrencyCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGroupForUserById = `-- name: GetGroupForUserById :one
SELECT
    g.id AS id,
    g.display_name AS group_name,
    g.state AS group_state,
    g.color_theme AS group_theme,
    g.created_at AS created_at,
    g.updated_at AS updated_at,
    g.currency_code AS currency_code,
    gm.role AS member_role,
    gm.state AS member_state,

    IFNULL(exp.total_expenses, 0.0) AS total_expenses,

    IFNULL(
        exp.total_expenses / NULLIF(mem.member_count, 0),
        0.0
    ) AS pay_per_member,

    IFNULL(user_exp.member_contribution, 0.0) AS member_contribution

FROM groups g
INNER JOIN group_members gm
    ON gm.group_id = g.id

LEFT JOIN (
    SELECT group_id, SUM(cost) AS total_expenses
    FROM group_expenses
    GROUP BY group_id
) exp ON exp.group_id = g.id

LEFT JOIN (
    SELECT group_id, COUNT(*) AS member_count
    FROM group_members
    GROUP BY group_id
) mem ON mem.group_id = g.id

LEFT JOIN (
    SELECT group_id, user_id, SUM(cost) AS member_contribution
    FROM group_expenses
    GROUP BY group_id, user_id
) user_exp
    ON user_exp.group_id = g.id
    AND user_exp.user_id = gm.user_id

WHERE gm.user_id = ?
  AND g.state != 'group_state:archived'
  AND g.id = ?
LIMIT 1
`

type GetGroupForUserByIdParams struct {
	UserID int64 `json:"user_id"`
	ID     int64 `json:"id"`
}

type GetGroupForUserByIdRow struct {
	ID                 int64       `json:"id"`
	GroupName          string      `json:"group_name"`
	GroupState         string      `json:"group_state"`
	GroupTheme         string      `json:"group_theme"`
	CreatedAt          time.Time   `json:"created_at"`
	UpdatedAt          time.Time   `json:"updated_at"`
	CurrencyCode       string      `json:"currency_code"`
	MemberRole         string      `json:"member_role"`
	MemberState        string      `json:"member_state"`
	TotalExpenses      interface{} `json:"total_expenses"`
	PayPerMember       interface{} `json:"pay_per_member"`
	MemberContribution interface{} `json:"member_contribution"`
}

// total group expenses
// total members
// this user's contribution
func (q *Queries) GetGroupForUserById(ctx context.Context, arg GetGroupForUserByIdParams) (GetGroupForUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getGroupForUserById, arg.UserID, arg.ID)
	var i GetGroupForUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.GroupName,
		&i.GroupState,
		&i.GroupTheme,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrencyCode,
		&i.MemberRole,
		&i.MemberState,
		&i.TotalExpenses,
		&i.PayPerMember,
		&i.MemberContribution,
	)
	return i, err
}

const getGroupsByUserId = `-- name: GetGroupsByUserId :many
SELECT
    g.id AS id,
    g.display_name AS group_name,
    g.state AS group_state,
    g.color_theme AS group_theme,
    g.created_at AS created_at,
    g.updated_at AS updated_at,
    g.currency_code AS currency_code,

    IFNULL(exp.total_expenses, 0.0) AS total_expenses,

    IFNULL(
        exp.total_expenses / NULLIF(mem.member_count, 0),
        0.0
    ) AS pay_per_member
FROM groups g
INNER JOIN group_members gm
    ON gm.group_id = g.id
LEFT JOIN (
    SELECT group_id, SUM(cost) AS total_expenses
    FROM group_expenses
    GROUP BY group_id
) exp ON exp.group_id = g.id

LEFT JOIN (
    SELECT group_id, COUNT(*) AS member_count
    FROM group_members
    GROUP BY group_id
) mem ON mem.group_id = g.id

WHERE gm.user_id=?
  AND g.state != 'group_state:archived'
GROUP BY g.id
ORDER BY gm.created_at DESC
`

type GetGroupsByUserIdRow struct {
	ID            int64       `json:"id"`
	GroupName     string      `json:"group_name"`
	GroupState    string      `json:"group_state"`
	GroupTheme    string      `json:"group_theme"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	CurrencyCode  string      `json:"currency_code"`
	TotalExpenses interface{} `json:"total_expenses"`
	PayPerMember  interface{} `json:"pay_per_member"`
}

// total group expenses
// total members
func (q *Queries) GetGroupsByUserId(ctx context.Context, userID int64) ([]GetGroupsByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGroupsByUserIdRow{}
	for rows.Next() {
		var i GetGroupsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupName,
			&i.GroupState,
			&i.GroupTheme,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrencyCode,
			&i.TotalExpenses,
			&i.PayPerMember,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGroupById = `-- name: UpdateGroupById :one
UPDATE groups
    SET 
        display_name=?,
        color_theme=?,
        updated_at=CURRENT_TIMESTAMP
    WHERE id = (
        SELECT groups.id
        FROM groups
        INNER JOIN group_members 
            ON group_members.group_id=groups.id
        WHERE groups.id=? AND group_members.user_id=?
    )
    RETURNING id, display_name, state, color_theme, created_at, updated_at
`

type UpdateGroupByIdParams struct {
	DisplayName string `json:"display_name"`
	ColorTheme  string `json:"color_theme"`
	ID          int64  `json:"id"`
	UserID      int64  `json:"user_id"`
}

type UpdateGroupByIdRow struct {
	ID          int64     `json:"id"`
	DisplayName string    `json:"display_name"`
	State       string    `json:"state"`
	ColorTheme  string    `json:"color_theme"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

func (q *Queries) UpdateGroupById(ctx context.Context, arg UpdateGroupByIdParams) (UpdateGroupByIdRow, error) {
	row := q.db.QueryRowContext(ctx, updateGroupById,
		arg.DisplayName,
		arg.ColorTheme,
		arg.ID,
		arg.UserID,
	)
	var i UpdateGroupByIdRow
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.State,
		&i.ColorTheme,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateGroupState = `-- name: UpdateGroupState :exec
UPDATE groups
    SET
        state=?,
        updated_at=CURRENT_TIMESTAMP
    WHERE id = (
        SELECT groups.id
        FROM groups
        INNER JOIN group_members 
            ON group_members.group_id=groups.id
        WHERE groups.id=? AND group_members.user_id=?
    )
`

type UpdateGroupStateParams struct {
	State  string `json:"state"`
	ID     int64  `json:"id"`
	UserID int64  `json:"user_id"`
}

func (q *Queries) UpdateGroupState(ctx context.Context, arg UpdateGroupStateParams) error {
	_, err := q.db.ExecContext(ctx, updateGroupState, arg.State, arg.ID, arg.UserID)
	return err
}

const updateGroupStateById = `-- name: UpdateGroupStateById :exec
UPDATE groups
SET state = ?1, updated_at = CURRENT_TIMESTAMP
WHERE id = ?2
`

type UpdateGroupStateByIdParams struct {
	GroupState string `json:"group_state"`
	GroupID    int64  `json:"group_id"`
}

func (q *Queries) UpdateGroupStateById(ctx context.Context, arg UpdateGroupStateByIdParams) error {
	_, err := q.db.ExecContext(ctx, updateGroupStateById, arg.GroupState, arg.GroupID)
	return err
}
