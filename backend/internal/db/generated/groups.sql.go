// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: groups.sql

package generated

import (
	"context"
	"time"
)

const archiveGroupById = `-- name: ArchiveGroupById :exec
UPDATE groups
SET state = "group_state:archived", updated_at = CURRENT_TIMESTAMP
    WHERE id IN (
        SELECT groups.id
        FROM groups
        INNER JOIN group_members
            ON groups.id=group_members.group_id
        WHERE groups.id=?1 AND group_members.role=?2 AND group_members.user_id=?3
    )
`

type ArchiveGroupByIdParams struct {
	GroupID    int64  `json:"group_id"`
	MemberRole string `json:"member_role"`
	UserID     int64  `json:"user_id"`
}

func (q *Queries) ArchiveGroupById(ctx context.Context, arg ArchiveGroupByIdParams) error {
	_, err := q.db.ExecContext(ctx, archiveGroupById, arg.GroupID, arg.MemberRole, arg.UserID)
	return err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO groups (display_name, state, color_theme) VALUES (?, ?, ?)
    RETURNING id, display_name, state, color_theme, created_at, updated_at
`

type CreateGroupParams struct {
	DisplayName string `json:"display_name"`
	State       string `json:"state"`
	ColorTheme  string `json:"color_theme"`
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, createGroup, arg.DisplayName, arg.State, arg.ColorTheme)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.State,
		&i.ColorTheme,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGroupForUserById = `-- name: GetGroupForUserById :one
SELECT g.id AS id,
    g.display_name AS group_name,
    g.state AS group_state,
    g.color_theme AS group_theme,
    g.created_at AS created_at,
    g.updated_at AS updated_at,
    gm.role AS member_role,
    gm.state AS member_state,
    IFNULL(SUM(e.cost), 0.0) AS total_expenses,
    IFNULL(
        SUM(e.cost) / NULLIF(COUNT(DISTINCT m.user_id), 0),
        0.0
    ) AS pay_per_member,

    IFNULL(
        SUM(CASE WHEN e.user_id = gm.user_id THEN e.cost ELSE 0 END),
        0.0
    ) AS member_contribution

    FROM groups g
    INNER JOIN group_members gm
        ON gm.group_id = g.id
    LEFT JOIN group_expenses e
        ON e.group_id = g.id
    LEFT JOIN group_members m
        ON m.group_id = g.id
    WHERE gm.user_id = ?
        AND g.state != 'group_state:archived'
        AND g.id=?
    GROUP BY g.id, gm.user_id
    LIMIT 1
`

type GetGroupForUserByIdParams struct {
	UserID int64 `json:"user_id"`
	ID     int64 `json:"id"`
}

type GetGroupForUserByIdRow struct {
	ID                 int64       `json:"id"`
	GroupName          string      `json:"group_name"`
	GroupState         string      `json:"group_state"`
	GroupTheme         string      `json:"group_theme"`
	CreatedAt          time.Time   `json:"created_at"`
	UpdatedAt          time.Time   `json:"updated_at"`
	MemberRole         string      `json:"member_role"`
	MemberState        string      `json:"member_state"`
	TotalExpenses      interface{} `json:"total_expenses"`
	PayPerMember       interface{} `json:"pay_per_member"`
	MemberContribution interface{} `json:"member_contribution"`
}

func (q *Queries) GetGroupForUserById(ctx context.Context, arg GetGroupForUserByIdParams) (GetGroupForUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getGroupForUserById, arg.UserID, arg.ID)
	var i GetGroupForUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.GroupName,
		&i.GroupState,
		&i.GroupTheme,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MemberRole,
		&i.MemberState,
		&i.TotalExpenses,
		&i.PayPerMember,
		&i.MemberContribution,
	)
	return i, err
}

const getGroupsByUserId = `-- name: GetGroupsByUserId :many
SELECT
    g.id AS id,
    g.display_name AS group_name,
    g.state AS group_state,
    g.color_theme AS group_theme,
    g.created_at AS created_at,
    g.updated_at AS updated_at,

    IFNULL(SUM(e.cost), 0.0) AS total_expenses,
    IFNULL(SUM(e.cost), 0.0) / COUNT(DISTINCT m.user_id) AS pay_per_member
FROM groups g
INNER JOIN group_members gm
    ON gm.group_id = g.id
LEFT JOIN group_expenses e
    ON e.group_id = g.id
LEFT JOIN group_members m
    ON m.group_id = g.id
WHERE gm.user_id = ?
  AND g.state != 'group_state:archived'
GROUP BY g.id
ORDER BY gm.created_at DESC
`

type GetGroupsByUserIdRow struct {
	ID            int64       `json:"id"`
	GroupName     string      `json:"group_name"`
	GroupState    string      `json:"group_state"`
	GroupTheme    string      `json:"group_theme"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	TotalExpenses interface{} `json:"total_expenses"`
	PayPerMember  int64       `json:"pay_per_member"`
}

func (q *Queries) GetGroupsByUserId(ctx context.Context, userID int64) ([]GetGroupsByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGroupsByUserIdRow{}
	for rows.Next() {
		var i GetGroupsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupName,
			&i.GroupState,
			&i.GroupTheme,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalExpenses,
			&i.PayPerMember,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGroupById = `-- name: UpdateGroupById :one
UPDATE groups
    SET 
        display_name=?,
        color_theme=?,
        updated_at=CURRENT_TIMESTAMP
    WHERE id = (
        SELECT groups.id
        FROM groups
        INNER JOIN group_members 
            ON group_members.group_id=groups.id
        WHERE groups.id=? AND group_members.user_id=?
    )
    RETURNING id, display_name, state, color_theme, created_at, updated_at
`

type UpdateGroupByIdParams struct {
	DisplayName string `json:"display_name"`
	ColorTheme  string `json:"color_theme"`
	ID          int64  `json:"id"`
	UserID      int64  `json:"user_id"`
}

func (q *Queries) UpdateGroupById(ctx context.Context, arg UpdateGroupByIdParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, updateGroupById,
		arg.DisplayName,
		arg.ColorTheme,
		arg.ID,
		arg.UserID,
	)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.State,
		&i.ColorTheme,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateGroupState = `-- name: UpdateGroupState :exec
UPDATE groups
    SET
        state=?,
        updated_at=CURRENT_TIMESTAMP
    WHERE id = (
        SELECT groups.id
        FROM groups
        INNER JOIN group_members 
            ON group_members.group_id=groups.id
        WHERE groups.id=? AND group_members.user_id=?
    )
`

type UpdateGroupStateParams struct {
	State  string `json:"state"`
	ID     int64  `json:"id"`
	UserID int64  `json:"user_id"`
}

func (q *Queries) UpdateGroupState(ctx context.Context, arg UpdateGroupStateParams) error {
	_, err := q.db.ExecContext(ctx, updateGroupState, arg.State, arg.ID, arg.UserID)
	return err
}

const updateGroupStateById = `-- name: UpdateGroupStateById :exec
UPDATE groups
SET state = ?1, updated_at = CURRENT_TIMESTAMP
WHERE id = ?2
`

type UpdateGroupStateByIdParams struct {
	GroupState string `json:"group_state"`
	GroupID    int64  `json:"group_id"`
}

func (q *Queries) UpdateGroupStateById(ctx context.Context, arg UpdateGroupStateByIdParams) error {
	_, err := q.db.ExecContext(ctx, updateGroupStateById, arg.GroupState, arg.GroupID)
	return err
}
